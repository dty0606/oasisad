prob_map <- prob_map^nei_cal
}
#Gaussian smoothing
prob_mask <- niftiarr(seg, 0)
prob_mask[indx] <- prob_map
prob_map <- fslsmooth(prob_mask, sigma = 1.25,
mask = brain_mask, retimg = TRUE,
smooth_mask = TRUE)
#return refined probability
return(prob_map[indx])
}
#' @title OASISAD optimal threshold selection function
#' @description This function will use an input cutoff list to select the optimal
#' cutoff with metric DSC(F1-score) based on validation data
#' @param probs Probability map
#' @param gs Gold standard of input voxels
#' @param cutoff A numeric vector includes threshold candidates
#' @return Refined probability map
opt_thre <- function(probs,
gs,
cutoff){
DSC <- vector()
gold <- factor(gs == 1, levels = c(TRUE,FALSE))
# DSC of each threshold candidate
for (j in seq(length(cutoff))) {
c <- cutoff[j]
preds <- factor(probs >= c, levels = c(TRUE,FALSE))
conf_mat <- table(gold, preds)
DSC[j] <- (2*conf_mat[1,1])/(2*conf_mat[1,1]+conf_mat[1,2]+conf_mat[2,1])
}
return(cutoff[which.max(DSC)])
}
#' Add process bar to sapply.
#'
#' @param X same argument in sapply.
#' @param FUN same argument in sapply.
#' @return results same as sapply
#' @examples
#' sapply_pb(1:10, function(i) i)
#sapply function with processing bar
sapply_pb <- function(X, FUN, ...)
{
env <- environment()
pb_Total <- length(X)
counter <- 0
pb <- txtProgressBar(min = 0, max = pb_Total, style = 3)
wrapper <- function(...){
curVal <- get("counter", envir = env)
assign("counter", curVal +1 ,envir=env)
setTxtProgressBar(get("pb", envir=env), curVal +1)
FUN(...)
}
res <- sapply(X, wrapper, ...)
close(pb)
res
}
#' @title OASISAD model
#' @description  The input should be OASISAD data list,
#' the function will train the model with training and vailidaion data,
#' then use the testing data to evaluatoin performance
#' @param train_df A data list from oasisad_df function which inlcudes training samples informatin.
#' If neighbor refinement function will be used, the list should include segmentation and
#' white matter probability map for each training subject
#' @param test_df A data list from oasisad_df function which inlcudes testing samples informatin.
#' If neighbor refinement function will be used, the list should include segmentation and
#' white matter probability map for each training subject
#' @param valid_df A data list from oasisad_df function which inlcudes validation samples informatin.
#' If neighbor refinement function will be used, the list should include segmentation and
#' white matter probability map for each training subject. If it is NULL, optimal threshold
#' algorithm will be used to calculate threshold
#' @param M1 A boolean indicates using full model 'M1' or reduced model 'M2',
#' default is reduced model
#' @param refine A boolean incicates whether use OASISAD refinement function,
#' to refine probability map from logistic regression model
#' @param neighbor A boolean incicates whether use neighbor refinement function,
#' to refine probability map from logistic regression model. If true, segmentation information and
#' white matter probability of brain is needed
#' @param wm_label White matter label in segmentation input
#' @param re_value A numeric value will be used in neighor refinement functoin to
#' refine a voxel's probability of being White matter hyperintensity
oasisad_model <- function(train_df,
test_df,
valid_df = NULL,
M1 = FALSE,
refine = FALSE,
neighbor = FALSE,
wm_label = NULL,
re_value = NULL) {
#train, val, test data
for(i in 1:length(train_df)){
if(i == 1){
train <- train_df[[i]]$data
} else {
train <- rbind(train, train_df[[i]]$data)
}
}
#
if(!is.null(valid_df)){
for(i in 1:length(valid_df)){
if(i == 1){
valid <- valid_df[[i]]$data
} else {
valid <- rbind(valid, valid_df[[i]]$data)
}
}
}
for(i in 1:length(test_df)){
if(i == 1){
test <- test_df[[i]]$data
} else {
test <- rbind(test, test_df[[i]]$data)
}
}
#masks for refinement
if(M1){
model <- glm(GoldStandard ~ flair*flair.1
+ flair*flair.2 + t1*t1.1 + t1*t1.2, family=binomial, data=train)
}else{
model <- glm(GoldStandard ~ flair+t1, family=binomial, data=train)
}
# if there is validation data, optimal threshold will be calculated
if(!is.null(valid_df)){
# the default cutoff_list is seq(0,1,0.01)
probs <- predict(model, valid, type = "response")
if(refine){
for(i in 1:length(valid_df)){
sub <- valid_df[[i]]
wm_mask <- sub$wm_mask
seg_mask <- sub$seg_mask
indx <- sub$data$indx
indx3d <- sub$data[c("axial", "coronal", "sagittal")]
}
probs <- oasis_refine(probs,
neighbor = neighbor,
seg = seg_mask,
wm = wm_mask,
wm_label = NULL,
re_value = NULL,
indx = indx,
indx3d = indx3d)
}
#gold standard
for(i in 1:length(valid_df)){
if(i == 1){
gs <- valid_df[[i]]$data$GoldStandard
} else {
gs <- rbind(gs, valid_df[[i]]$data$GoldStandard)
}
}
#optimal threshold will use DSC(F1-score) as metric
cutoff <- seq(0,1,0.01)
opt_cut <- opt_thre(probs,gs=gs, cutoff)
}
## Apply to test data
probs_list <- list()
for(i in 1:length(test_df)){
probs <- predict(model, test, type = "response")
if(refine){
sub <- test_df[[i]]
wm_mask <- sub$wm_mask
seg_mask <- sub$seg_mask
indx <- sub$data$indx
indx3d <- sub$data[c("axial", "coronal", "sagittal")]
probs <- oasis_refine(probs,
neighbor = neighbor,
seg = seg_mask,
wm = wm_mask,
wm_label = NULL,
re_value = NULL,
indx = indx,
indx3d = indx3d)
}
probs_list[[i]] <- probs
}
L <- list(coef = model$coefficients,
cutoff = opt_cut,
probs = probs_list
)
}
model_res <- oasisad_model(train_df = train_df,
test_df = test_df,
valid_df = valid_df,
M1 = TRUE,
refine = TRUE,
neighbor = TRUE,
wm_label = NULL,
re_value = NULL)
model_res$coef
model_res$cutoff
hist(model_res$probs)
hist(model_res$probs[[1]])
#' @title OASISAD evaluation function
#' @description Evaluate performance of segmentation models based on their outputs
#' @param pred a vector includes predicted labels from model.
#' @param truth a vector includes true labels. Please check labels' names in pred and truth are same.
#' @param pos_l a value indicates the positive label. If \emph{NULL}, default will set last value from \emph{table} function as positive label.
#' @return a table includes evaluation metrics.
oasisad_eva <- function(pred,
truth,
probs,
pos_l = NULL){
if(!is.null(pos_l)){
truth <- truth == pos_l
pred <- pred == pos_l
}
# Confusion matrix
x <- table(truth, pred) # confusion matrix
TP <- x[2,2] ## if "1" is positive
TN <- x[1,1] ## if "0" is negative
FP <- x[1,2]
FN <- x[2,1]
# Metrics table
accuracy = (TP+TN)/n.obs # accuracy
if((FP+TP)!=0) precision = TP/(FP+TP) else precisoin = 0 #positive predicted value
if((FN+TP)!=0) recall = TP/(FN+TP) else  recall = 0 #true positive rate
if((TN+FP)!=0) fpr = FP/(TN+FP) else fpr = 0 #false positive rate
if((2*TP + FP +FN)!=0) Dsc = 2*TP/(2*TP + FP +FN) else Dsc = 0 #dice similarity score i.e. F1-score
measure = c(accuracy, precision, recall, fpr, Dsc)
names(measure) = c("Accuracy", "Precision", "Recall",'fpr',"Dsc")
return(measure)
}
#evaluate
preds <- model_res$probs[[1]] > model_res$cutoff
#' @title OASISAD evaluation function
#' @description Evaluate performance of segmentation models based on their outputs
#' @param pred a vector includes predicted labels from model.
#' @param truth a vector includes true labels. Please check labels' names in pred and truth are same.
#' @param pos_l a value indicates the positive label. If \emph{NULL}, default will set last value from \emph{table} function as positive label.
#' @return a table includes evaluation metrics.
oasisad_eva <- function(pred,
truth,
pos_l = NULL){
if(!is.null(pos_l)){
truth <- truth == pos_l
pred <- pred == pos_l
}
# Confusion matrix
x <- table(truth, pred) # confusion matrix
TP <- x[2,2] ## if "1" is positive
TN <- x[1,1] ## if "0" is negative
FP <- x[1,2]
FN <- x[2,1]
# Metrics table
accuracy = (TP+TN)/n.obs # accuracy
if((FP+TP)!=0) precision = TP/(FP+TP) else precisoin = 0 #positive predicted value
if((FN+TP)!=0) recall = TP/(FN+TP) else  recall = 0 #true positive rate
if((TN+FP)!=0) fpr = FP/(TN+FP) else fpr = 0 #false positive rate
if((2*TP + FP +FN)!=0) Dsc = 2*TP/(2*TP + FP +FN) else Dsc = 0 #dice similarity score i.e. F1-score
measure = c(accuracy, precision, recall, fpr, Dsc)
names(measure) = c("Accuracy", "Precision", "Recall",'fpr',"Dsc")
return(measure)
}
#evaluate
preds <- model_res$probs[[1]] > model_res$cutoff
eva <- oasisad_eva(pred = preds,
truth = test_df[[1]]$data$GoldStandard)
#' @title OASISAD evaluation function
#' @description Evaluate performance of segmentation models based on their outputs
#' @param pred a vector includes predicted labels from model.
#' @param truth a vector includes true labels. Please check labels' names in pred and truth are same.
#' @param pos_l a value indicates the positive label. If \emph{NULL}, default will set last value from \emph{table} function as positive label.
#' @return a table includes evaluation metrics.
oasisad_eva <- function(pred,
truth,
pos_l = NULL){
#number of subject
n.obs <- length(pred)
if(!is.null(pos_l)){
truth <- truth == pos_l
pred <- pred == pos_l
}
# Confusion matrix
x <- table(truth, pred) # confusion matrix
TP <- x[2,2] ## if "1" is positive
TN <- x[1,1] ## if "0" is negative
FP <- x[1,2]
FN <- x[2,1]
# Metrics table
accuracy = (TP+TN)/n.obs # accuracy
if((FP+TP)!=0) precision = TP/(FP+TP) else precisoin = 0 #positive predicted value
if((FN+TP)!=0) recall = TP/(FN+TP) else  recall = 0 #true positive rate
if((TN+FP)!=0) fpr = FP/(TN+FP) else fpr = 0 #false positive rate
if((2*TP + FP +FN)!=0) Dsc = 2*TP/(2*TP + FP +FN) else Dsc = 0 #dice similarity score i.e. F1-score
measure = c(accuracy, precision, recall, fpr, Dsc)
names(measure) = c("Accuracy", "Precision", "Recall",'fpr',"Dsc")
return(measure)
}
#evaluate
preds <- model_res$probs[[1]] > model_res$cutoff
eva <- oasisad_eva(pred = preds,
truth = test_df[[1]]$data$GoldStandard)
eva
#' @title OASISAD calculates neighbor indices function
#' @description Input voxel's index information to calculate its neighbor indices
#' @param x Voxel's 3D indices
#' @param dim Dimension of 3D image
#' @return Refined probability map
neighbor_indx <- function(x,
dim){
#grid
temp <- expand.grid(c(x[1]-1,x[1],x[1]+1),
c(x[2]-1,x[2],x[2]+1),
c(x[3]-1,x[3],x[3]+1))
#calculate distance
temp1 <- cbind(temp,
(temp[,1]-x[1])^2 + (temp[,2]-x[2])^2 + (temp[,3]-x[3])^2)
#select nearest neighbor
temp <- temp[which(temp1[,4]==1),]
#return their vectorized indice
indx <- temp[,1] + (temp[,2]-1)*dim[1] + (temp[,3]-1)*dim[1]*dim[2]
return(indx)
}
install.packages("roxygen2")
install.packages(extrantsr)
install.packages('extrantsr')
update.packages('extrantsr')
version
#data
install_github("dty0606/oasisad")
#data
library(devtool)
#data
library(devtools)
install_github("dty0606/oasisad")
library(oasisad)
rm(list = ls())
#load data
setwd('data')
getwd()
#load data
setwd('oasisad/data')
temp <- readnii('test1_gs.nii')
library(neurobase)
#data
library(neurobase)
#data
library(neurobase)
library(devtools)
rm(list = ls())
library(oasisad)
#load data
setwd('oasisad/data')
temp <- readnii('test1_gs.nii')
writenii(temp,'test1_gs')
temp <- readnii('train1_gs.nii')
writenii(temp,'train1_gs')
temp <- readnii('valid1_gs.nii')
writenii(temp,'valid1_gs')
validraw <-list(flair = list(), t1 = list(), gs = list())
testraw <-list(flair = list(), t1 = list(), gs = list())
trainraw <-list(flair, t1 , gs )
trainraw$flair[[1]] <- readnii('train1_flair.nii.gz')
trainraw <-list(flair = list(), t1 = list(), gs = list())
validraw <-list(flair = list(), t1 = list(), gs = list())
testraw <-list(flair = list(), t1 = list(), gs = list())
trainraw$flair[[1]] <- readnii('train1_flair.nii.gz')
trainraw$t1[[1]] <- readnii('train1_t1.nii.gz')
trainraw$gs[[1]] <- readnii('train1_gs.nii.gz')
validraw$flair[[1]] <- readnii('valid1_flair.nii.gz')
validraw$t1[[1]] <- readnii('valid1_t1.nii.gz')
validraw$gs[[1]] <- readnii('valid1_gs.nii.gz')
testraw$flair[[1]] <- readnii('test1_flair.nii.gz')
testraw$t1[[1]] <- readnii('test1_t1.nii.gz')
testraw$gs[[1]] <- readnii('test1_gs.nii.gz')
# training sample dataframe list
train_list <- list()
rm(list = ls())
library(oasisad)
#load data
setwd('oasisad/data')
train_raw <-list(flair = list(), t1 = list(), gs = list())
valid_raw <-list(flair = list(), t1 = list(), gs = list())
test_raw <-list(flair = list(), t1 = list(), gs = list())
train_raw$flair[[1]] <- readnii('train1_flair.nii.gz')
train_raw$t1[[1]] <- readnii('train1_t1.nii.gz')
train_raw$gs[[1]] <- readnii('train1_gs.nii.gz')
valid_raw$flair[[1]] <- readnii('valid1_flair.nii.gz')
valid_raw$t1[[1]] <- readnii('valid1_t1.nii.gz')
valid_raw$gs[[1]] <- readnii('valid1_gs.nii.gz')
test_raw$flair[[1]] <- readnii('test1_flair.nii.gz')
test_raw$t1[[1]] <- readnii('test1_t1.nii.gz')
test_raw$gs[[1]] <- readnii('test1_gs.nii.gz')
# training sample dataframe list
train_list <- list()
for(i in 1:length(train_id)){
train_list[[i]] <- oasisad_df(flair = train_raw$flair[[i]], ##flair volume of class nifti
t1 = train_raw$t1[[i]], ##t1 volume of class nifti
t2 = NULL, ##t2 volume of class nifti
pd = NULL, ##pd volume of class nifti
gold_standard = train_raw$gs[[i]], ##gold standard mask of class nifti
preproc = TRUE, ##option to preprocess the data
brain_mask = NULL, ##brain mask of class nifti
img_space = NULL, ## if create brain mask, use T1 or FLAIR
neighbor = TRUE,
wm_mask = NULL,
seg_mask = NULL,
dir = paste0('fslout/train',i),
eroder = TRUE,
voxel_select = NULL, ##a specifed level to remove voxels whose intensity under
normalize = TRUE, ##option to normalize
image_sm = TRUE, ## option to smooth image
slices = NULL, #slice vector
orientation = c("axial", "coronal", "sagittal"),
return_preproc = FALSE,
cores = 1,
verbose = TRUE
)
}
# training sample dataframe list
train_list <- list()
for(i in 1:length(train_raw)){
train_list[[i]] <- oasisad_df(flair = train_raw$flair[[i]], ##flair volume of class nifti
t1 = train_raw$t1[[i]], ##t1 volume of class nifti
t2 = NULL, ##t2 volume of class nifti
pd = NULL, ##pd volume of class nifti
gold_standard = train_raw$gs[[i]], ##gold standard mask of class nifti
preproc = TRUE, ##option to preprocess the data
brain_mask = NULL, ##brain mask of class nifti
img_space = NULL, ## if create brain mask, use T1 or FLAIR
neighbor = TRUE,
wm_mask = NULL,
seg_mask = NULL,
dir = paste0('fslout/train',i),
eroder = TRUE,
voxel_select = NULL, ##a specifed level to remove voxels whose intensity under
normalize = TRUE, ##option to normalize
image_sm = TRUE, ## option to smooth image
slices = NULL, #slice vector
orientation = c("axial", "coronal", "sagittal"),
return_preproc = FALSE,
cores = 1,
verbose = TRUE
)
}
# training sample dataframe list
train_list <- list()
for(i in 1:length(train_raw)){
train_list[[i]] <- oasisad_df(flair = train_raw$flair[[i]], ##flair volume of class nifti
t1 = train_raw$t1[[i]], ##t1 volume of class nifti
t2 = NULL, ##t2 volume of class nifti
pd = NULL, ##pd volume of class nifti
gold_standard = train_raw$gs[[i]], ##gold standard mask of class nifti
preproc = TRUE, ##option to preprocess the data
brain_mask = NULL, ##brain mask of class nifti
img_space = NULL, ## if create brain mask, use T1 or FLAIR
neighbor = TRUE,
wm_mask = NULL,
seg_mask = NULL,
dir = paste0('fslout/train',i),
eroder = TRUE,
voxel_select = NULL, ##a specifed level to remove voxels whose intensity under
normalize = TRUE, ##option to normalize
image_sm = TRUE, ## option to smooth image
slices = NULL, #slice vector
orientation = c("axial", "coronal", "sagittal"),
return_pre = FALSE,
cores = 1,
verbose = TRUE
)
}
library(extrantsr)
#data
library(neurobase)
fslr::pixdim
?pixdim
extrantsr::checkimg
extrantsr::readnii
utlis
#load data
setwd('../data/')
train_raw <-list(flair = list(), t1 = list(), gs = list())
valid_raw <-list(flair = list(), t1 = list(), gs = list())
test_raw <-list(flair = list(), t1 = list(), gs = list())
train_raw$flair[[1]] <- readnii('train1_flair.nii.gz')
train_raw$t1[[1]] <- readnii('train1_t1.nii.gz')
train_raw$gs[[1]] <- readnii('train1_gs.nii.gz')
valid_raw$flair[[1]] <- readnii('valid1_flair.nii.gz')
valid_raw$t1[[1]] <- readnii('valid1_t1.nii.gz')
valid_raw$gs[[1]] <- readnii('valid1_gs.nii.gz')
test_raw$flair[[1]] <- readnii('test1_flair.nii.gz')
test_raw$t1[[1]] <- readnii('test1_t1.nii.gz')
test_raw$gs[[1]] <- readnii('test1_gs.nii.gz')
fslr::correction
#data
library(neurobase)
library(devtools)
library(extrantsr)
install_github("dty0606/oasisad")
library(oasisad)
#load data
setwd('../data/')
library(oasisad)
#load data
setwd('../data/')
train_raw <-list(flair = list(), t1 = list(), gs = list())
valid_raw <-list(flair = list(), t1 = list(), gs = list())
test_raw <-list(flair = list(), t1 = list(), gs = list())
train_raw$flair[[1]] <- readnii('train1_flair.nii.gz')
train_raw$t1[[1]] <- readnii('train1_t1.nii.gz')
train_raw$gs[[1]] <- readnii('train1_gs.nii.gz')
valid_raw$flair[[1]] <- readnii('valid1_flair.nii.gz')
valid_raw$t1[[1]] <- readnii('valid1_t1.nii.gz')
valid_raw$gs[[1]] <- readnii('valid1_gs.nii.gz')
test_raw$flair[[1]] <- readnii('test1_flair.nii.gz')
test_raw$t1[[1]] <- readnii('test1_t1.nii.gz')
test_raw$gs[[1]] <- readnii('test1_gs.nii.gz')
install_github("dty0606/oasisad")
library(oasisad)
library(oasisad)
install_github("dty0606/oasisad")
library(oasisad)
?oasisad
